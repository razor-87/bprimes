//go:build ignore
// +build ignore

package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strconv"
)

const (
	m         = 100
	k         = 1000
	blocksLen = 1000  // limit/k
	template  = "%#X" // or "%#b"
)

//go:generate go run gen.go

func main() {
	f, err := os.Open("data/1M.txt")
	if err != nil {
		log.Fatal(err)
	}
	defer f.Close()

	buf := bytes.NewBuffer([]byte(`// Code generated by go generate gen.go; DO NOT EDIT.`))
	fmt.Fprintln(buf, "\n\npackage bprimes")
	fmt.Fprintln(buf, "\ntype block [10]uint64")
	fmt.Fprintf(buf, "\n%s%d%s\n", "var blocks = [", blocksLen, "]block{")

	var (
		p, i   int
		bitset uint64
	)
	newLine := true
	sc := bufio.NewScanner(f)

	for sc.Scan() {
		p, _ = strconv.Atoi(sc.Text())

		if (p%k)/m != i {
			fmt.Fprintf(buf, template, bitset)
			if i != 9 {
				fmt.Fprint(buf, ",")
			} else {
				fmt.Fprintln(buf, "},")
				newLine = true
			}
			bitset = 0
		}

		if newLine {
			fmt.Fprint(buf, "\t{")
			newLine = false
		}

		bitset |= (1 << odd2Bit[uint8(p%m)])
		i = (p % k) / m
	}

	fmt.Fprintf(buf, template, bitset)
	fmt.Fprintln(buf, "},")
	fmt.Fprintln(buf, "}")

	if err := sc.Err(); err != nil {
		log.Fatal(err)
	}

	out, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}

	if err := os.WriteFile("blocks.go", out, 0666); err != nil {
		log.Fatal(err)
	}
}

var odd2Bit = map[uint8]uint8{
	1:  0,
	3:  1,
	5:  2,
	7:  3,
	9:  4,
	11: 5,
	13: 6,
	15: 7,
	17: 8,
	19: 9,
	21: 10,
	23: 11,
	25: 12,
	27: 13,
	29: 14,
	31: 15,
	33: 16,
	35: 17,
	37: 18,
	39: 19,
	41: 20,
	43: 21,
	45: 22,
	47: 23,
	49: 24,
	51: 25,
	53: 26,
	55: 27,
	57: 28,
	59: 29,
	61: 30,
	63: 31,
	65: 32,
	67: 33,
	69: 34,
	71: 35,
	73: 36,
	75: 37,
	77: 38,
	79: 39,
	81: 40,
	83: 41,
	85: 42,
	87: 43,
	89: 44,
	91: 45,
	93: 46,
	95: 47,
	97: 48,
	99: 49,
}
